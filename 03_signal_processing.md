# 3. 생체신호 처리와 정보검출

## 3.1 신호의 이해 (Signal Understanding)

- **개요/목표:**
  - 생체신호를 어떻게 측정하여 데이터화 할 것인가?
  - 측정된 생체신호로부터 어떻게 유용한 정보를 추출할 것인가?

- **생체신호의 측정:**
  - **원리:** 인체 기관은 기계적/전기적 등 다양한 형태로 활동하며 신호를 발생시킴
  - **측정:**
    - **연결/접촉:** 인간과 장비 간의 연결 필요 → **전극(Electrode)** 사용
    - **변환/감지:** 인체의 미세한 변화(신호)를 감지하고 다른 형태의 에너지(주로 전기)로 변환 → **센서(Sensor)** 사용

- **센서와 변환기(Transducer):**
  - **변환기:** 어떤 형태의 에너지를 *다른* 형태의 에너지로 변환하는 장치 
    - *예시*: 스피커 - 전기→소리(기계진동)
  - **센서:** 특정 물리량/화학량(에너지)을 감지하여 *전기적 신호*로 변환하는 장치 (변환기의 일종)
    - *예시*: 압력센서 - 압력→전기

- **생체신호의 처리:**
  - **1단계 (측정):** 센서/전극을 통해 인체 신호(에너지)가 전기 신호로 변환됨
  - **2단계 (증폭 Amplification):** 생체신호는 매우 미약하므로 (수 uV ~ mV), 분석 가능한 수준으로 신호 크기를 키움
  - **3단계 (필터링 Filtering):** 측정된 전기 신호에서 원하는 생체신호만 분리하고 잡음(Noise) 제거
  - **4단계 (디지털 변환 Analog-to-Digital Conversion, ADC):**
    - 자연계/생체 신호는 **아날로그(연속) 신호**
    - 컴퓨터 처리를 위해 **디지털(이산) 신호**로 변환 필요
    - **샘플링(Sampling):** 연속 신호를 일정한 시간 간격으로 측정하여 불연속적인 데이터 값으로 만드는 과정
    - **샘플링 레이트(Sampling Rate):** 1초당 샘플링하는 횟수 (단위: Hz 또는 samples/sec)
    - **나이퀴스트 샘플링 정리(Nyquist Sampling Theorem):** 원 신호의 정보를 손실 없이 디지털화하려면, 원 신호가 가진 **최대 주파수의 2배 이상**으로 샘플링해야 함 (부족하면 Aliasing 현상 발생)

- **신호의 주파수(Frequency):**
  - 1초당 진동하는 횟수 (단위: Hz). 주기(Period)의 역수 (f = 1/T)
  - 자연계의 신호는 대부분 다양한 주파수 성분이 혼합된 형태

- **필터링(Filtering) 상세:**
  - 측정 신호(`x[n]`)에서 원하는 신호(`y[n]`)만 추출하는 과정
  - 수학적 표현: `y[n] = H{x[n]}` (H는 필터 시스템)
  - 원치 않는 주파수 대역의 신호를 제거 (예: 전원 노이즈(60Hz), 근전도 간섭 등)

- **정리 (생체신호 측정 및 처리 흐름):**
  ```
  인체 신호 → 센서/전극 (변환) → 증폭 → 필터링 → ADC (샘플링) → 컴퓨터 (디지털 데이터)
  ```

## 3.2 합성곱의 이해 (Understanding Convolution)

- **목표:** 측정된 생체신호(숫자 값들의 배열)를 어떻게 수학적으로 처리하여 원하는 신호(필터링된 신호)를 얻을 것인가?

- **핵심:** **시간 영역(Time Domain)에서의 필터링 = 합성곱(Convolution)** 연산

- **합성곱 (Convolution) 정의:**
  - 하나의 함수(신호 `x[n]`)와 다른 함수(필터 `h[n]`)를 **반전(Flip) 및 이동(Shift)** 시킨 값을 **곱한(Multiply)** 후, 전체 구간에 대해 **더하는(Sum)** 수학 연산자
  - 기호: `y[n] = x[n] * h[n]` (*는 합성곱 연산자)

- **합성곱 과정 시각화 (FSMS: Flip, Shift, Multiply, Sum):**
  - **1. 반전 (Flip):** 필터 함수 `h[k]`를 시간 축(k=0) 기준으로 뒤집는다 → `h[-k]`
    - *이유*: 현재 시점의 출력을 계산하기 위해 과거 입력값과 필터의 해당 부분을 곱해야 하므로, 필터를 뒤집어 시간 순서를 맞춤
  - **2. 이동 (Shift):** 뒤집힌 필터 `h[n-k]`를 입력 신호 `x[k]` 위에서 시간 `n`만큼 이동시킨다
  - **3. 곱셈 (Multiply):** 이동된 위치에서 입력 신호 `x[k]`와 뒤집힌 필터 `h[n-k]`의 겹치는 부분들을 각 점(k)마다 곱한다
  - **4. 합산 (Sum):** 곱해진 모든 값들을 더하여 현재 시점 `n`에서의 출력값 `y[n]`을 얻는다
    - `y[n] = Σ x[k] * h[n-k]` (모든 k에 대해)

- **2D 합성곱:** 이미지 처리(엣지 검출 등), 합성곱 신경망(CNN) 등에서 사용됨 (개념 확장)

- **임펄스 함수 (Impulse Function, δ[n]):**
  - **정의:** `n=0`일 때만 값이 1이고, 나머지 모든 `n`에서는 0인 함수 (크로네커 델타)
  - **특성:** 어떤 신호 `x[n]`에 임펄스 함수 `δ[n-k]`를 곱하면, `n=k` 시점의 신호 값 `x[k]`만 남게 됨
    - `x[n] * δ[n-k] = x[k] * δ[n-k]`
  - **신호 표현:** 모든 이산 신호 `x[n]`은 각 시점의 신호 값 `x[k]`로 크기가 조절되고 해당 시점 `k`로 이동된 임펄스 함수들의 합으로 표현 가능
    - `x[n] = Σ x[k] * δ[n-k]` (모든 k에 대해)

- **합성곱의 수학적 유도 (LTI 시스템 가정):**
  - 시스템 출력 `y[n] = H{x[n]}`
  - `x[n]`을 임펄스 합으로 대체: `y[n] = H{ Σ x[k] * δ[n-k] }`
  - 선형성(Linearity): `y[n] = Σ x[k] * H{δ[n-k]}`
  - 시불변성(Time-Invariance): 시스템 `H`에 대한 임펄스 응답(Impulse Response)을 `h[n] = H{δ[n]}`이라 하면, `H{δ[n-k]} = h[n-k]`
  - 결론: `y[n] = Σ x[k] * h[n-k]`. 이것이 바로 합성곱의 정의
  - **임펄스 응답 `h[n]`:** 시스템(필터)에 임펄스 입력 `δ[n]`을 넣었을 때 나오는 출력. 이 `h[n]`이 바로 필터의 특성을 나타내며, 합성곱 연산에 사용되는 '필터 함수'임

- **합성곱 공식:**
  - `y[n] = x[n] * h[n] = Σ x[k] * h[n-k] = Σ h[k] * x[n-k]` (k는 모든 범위)

- **필터링과 합성곱 요약:**
  - 측정된 신호에서 원치 않는 성분을 제거하는 필터링은 수학적으로 **합성곱 연산**을 통해 이루어진다
  - 필터의 특성(어떤 주파수를 통과시키고 차단할지)은 **임펄스 응답 `h[n]`**의 값들에 의해 결정된다
